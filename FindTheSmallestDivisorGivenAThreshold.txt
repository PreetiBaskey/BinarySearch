//approach - 1 - binary search on answer
//time complexity - O(n * log(max(range)))
//space complextiy - O(1)
class Solution {
public:
    bool isPossible(vector<int> &nums, int threshold, int divisor) {
        int n = nums.size();

        int sum = 0;
        for(int i = 0; i < n; i++) {
            // sum += ceil(nums[i]/divisor);
            sum += (nums[i] + divisor - 1) / divisor;
        }

        if(sum <= threshold) {
            return true;
        }

        return false;
    }
    int smallestDivisor(vector<int>& nums, int threshold) {
        int n = nums.size();

        int maxEle = *max_element(begin(nums), end(nums));

        int result = maxEle;
        int left = 1, right = maxEle;
        while(left <= right) {
            int mid = left + (right - left) / 2;

            if(isPossible(nums, threshold, mid)) {
                result = mid;
                right = mid - 1;
            }
            else {
                left = mid + 1;
            }
        }

        return result;
    }
};
