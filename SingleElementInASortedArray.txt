//approach - 1 - using unordered_map - but asked to solve with O(logn)
//time complexity - O(n)
//space complexity - O(n)
// class Solution {
// public:
//     int singleNonDuplicate(vector<int>& nums) {
//         unordered_map<int, int> mp;

//         for(int &num: nums) {
//             mp[num]++;
//         }

//         int result = 0;
//         for(auto &it: mp) {
//             if(it.second == 1) {
//                 result = it.first;
//             }
//         }

//         return result;
//     }
// };



//approach - 2 - using xor - but asked to solve with O(logn)
//time complexity - O(n)
//space complexity - O(1)
// class Solution {
// public:
//     int singleNonDuplicate(vector<int>& nums) {
//         int result = 0;
//         for(int &num: nums) {
//             result = result ^ num;
//         }

//         return result;
//     }
// };




//approach - 3 - binary search - asked solution
//time complexity - O(logn)
//space complexity - O(1)
class Solution {
public:
    int singleNonDuplicate(vector<int>& nums) {
        int n = nums.size();

        int left = 0, right = n - 1;
        while(left < right) {
            int mid = left + (right - left) / 2;

            int isEven;
            if((right - mid) % 2 == 0) { //if mid + 1 to right has even or odd numbers
                isEven = true;
            }
            else {
                isEven = false;
            }

            if(nums[mid] == nums[mid + 1]) {
                //condition 1 - [a, a, x, x, x], (2nd to x - even numbers)
                if(isEven) {
                    left = mid + 2;
                }
                //condition 2 - [a, a, x, x], (2nd a to x - odd numbers)
                else {
                    right = mid - 1;
                }
            }
            else if(nums[mid] != nums[mid + 1]) {
                //condition 3 - [a, b, x, x, x], (b to x - even numbers)
                if(isEven) {
                    right = mid;
                }
                //condition 4 - [a, b, x, x], (b to x - odd numbers)
                else {
                    left = mid + 1;
                }
            }
        }

        return nums[left];
    } 
};
